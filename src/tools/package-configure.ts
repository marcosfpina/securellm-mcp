// Package Configure Tool - Generate intelligent package configuration
import { z } from "zod";
import { spawn } from "child_process";
import { readFile } from "fs/promises";
import type { BuildMethod, ConfigureResult } from "../types/package-debugger.js";

// Input schema for package_configure tool
export const packageConfigureSchema = z.object({
  package_name: z.string().describe("Name of the package"),
  package_type: z.enum(["tar", "deb", "js"]).describe("Type of package system"),
  storage_file: z.string().describe("Path to downloaded file in storage"),
  sha256: z.string().describe("SHA256 hash of the file"),
  options: z.object({
    method: z.enum(["auto", "native", "fhs"]).optional().describe("Build method (auto-detected if not specified)"),
    sandbox: z.boolean().optional().default(false).describe("Enable sandboxing"),
    audit: z.boolean().optional().default(true).describe("Enable audit logging"),
    executable: z.string().optional().describe("Explicit executable path (auto-detected if not specified)"),
    npm_flags: z.array(z.string()).optional().describe("NPM build flags"),
  }).optional().default({}),
});

export type PackageConfigureInput = z.infer<typeof packageConfigureSchema>;

export class PackageConfigureTool {
  private workspaceDir: string;

  constructor(workspaceDir: string) {
    this.workspaceDir = workspaceDir;
  }

  /**
   * Main configure function
   */
  async configure(input: PackageConfigureInput): Promise<ConfigureResult> {
    try {
      const options = input.options || {};
      
      // Determine package type specific configuration
      let configContent: string;
      let detectedExecutables: string[] = [];
      let detectedDependencies: string[] = [];
      let buildMethod: BuildMethod = options.method || "auto";

      switch (input.package_type) {
        case "tar":
          const tarResult = await this.configureTarPackage(
            input.package_name,
            input.storage_file,
            input.sha256,
            options
          );
          configContent = tarResult.content;
          detectedExecutables = tarResult.executables;
          buildMethod = tarResult.method;
          break;

        case "js":
          const jsResult = await this.configureJsPackage(
            input.package_name,
            input.storage_file,
            input.sha256,
            options
          );
          configContent = jsResult.content;
          detectedDependencies = jsResult.dependencies;
          break;

        case "deb":
          const debResult = await this.configureDebPackage(
            input.package_name,
            input.storage_file,
            input.sha256,
            options
          );
          configContent = debResult.content;
          break;

        default:
          return {
            status: "error",
            error: `Unsupported package type: ${input.package_type}`,
          };
      }

      // Determine config file path
      const configFile = this.getConfigFilePath(input.package_type, input.package_name);

      return {
        status: "success",
        config_file: configFile,
        config_content: configContent,
        detected_executables: detectedExecutables.length > 0 ? detectedExecutables : undefined,
        detected_dependencies: detectedDependencies.length > 0 ? detectedDependencies : undefined,
        build_method: buildMethod,
      };
    } catch (error) {
      return {
        status: "error",
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Configure TAR package
   */
  private async configureTarPackage(
    packageName: string,
    storageFile: string,
    sha256: string,
    options: any
  ): Promise<{ content: string; executables: string[]; method: BuildMethod }> {
    // Extract and inspect tarball
    const inspection = await this.inspectTarball(`${this.workspaceDir}/${storageFile}`);
    
    // Detect executables
    const executables = options.executable 
      ? [options.executable] 
      : inspection.executables;

    // Determine build method
    const method = this.selectBuildMethod(
      options.method || "auto",
      inspection.hasLibraries,
      inspection.complexity
    );

    // Select primary executable
    const primaryExecutable = executables[0] || packageName;

    // Generate configuration
    const content = `# ${packageName} - Package Configuration
# Auto-generated by MCP Package Debugger
{
  ${packageName} = {
    enable = true;

    # Build method - ${method === "native" ? "native (simple binary/script)" : "FHS environment (complex dependencies)"}
    method = "${method}";

    # Source configuration
    source = {
      path = ../storage/${storageFile.split('/').pop()};
      sha256 = "${sha256}";
    };

    # Wrapper configuration
    wrapper = {
      # Primary executable: ${primaryExecutable}
      ${executables.length > 1 ? `# Other executables found: ${executables.slice(1).join(", ")}` : ""}
      executable = "${primaryExecutable}";
      environmentVariables = {
        # Add environment variables if needed
        ${inspection.needsHome ? '# HOME = "$HOME"; # Uncomment if package needs home directory' : ""}
      };
    };

    # Sandbox configuration
    sandbox = {
      enable = ${options.sandbox || false};
      blockHardware = [${options.sandbox ? ' "nvidia" "amdgpu" ' : ''}];
      allowedPaths = [${options.sandbox ? ' "$HOME" ' : ''}];
    };

    # Audit configuration
    audit = {
      enable = ${options.audit !== false};
      logLevel = "${options.audit === false ? 'none' : 'info'}";
    };

    # Desktop entry (set to null for CLI tools)
    ${inspection.hasGui ? '# desktopEntry = { name = "' + packageName + '"; ... };' : '# No desktop entry for CLI tool'}
  };
}
`;

    return { content, executables, method };
  }

  /**
   * Configure JavaScript/NPM package
   */
  private async configureJsPackage(
    packageName: string,
    storageFile: string,
    sha256: string,
    options: any
  ): Promise<{ content: string; dependencies: string[] }> {
    // Inspect package.json if available
    const inspection = await this.inspectNpmPackage(`${this.workspaceDir}/${storageFile}`);
    
    const dependencies: string[] = [];
    
    // Check for common native dependencies
    if (inspection.hasNativeModules) {
      dependencies.push("python3", "pkg-config");
    }
    
    if (inspection.needsLibsecret) {
      dependencies.push("libsecret");
    }

    if (inspection.needsGtk) {
      dependencies.push("gtk3");
    }

    // Generate configuration
    const content = `# ${packageName} - NPM Package Configuration
# Auto-generated by MCP Package Debugger
{ pkgs }:

pkgs.buildNpmPackage {
  pname = "${packageName}";
  version = "1.0.0"; # TODO: Update with actual version from package.json

  src = pkgs.fetchurl {
    url = "file://${this.workspaceDir}/${storageFile}";
    sha256 = "${sha256}";
  };

  # Run build once to get the correct npmDepsHash from the error message
  npmDepsHash = ""; # TODO: Fill with hash from first build attempt

  ${dependencies.length > 0 ? `# Native build dependencies
  nativeBuildInputs = with pkgs; [
    ${dependencies.filter(d => ["python3", "pkg-config"].includes(d)).join("\n    ")}
  ];

  # Runtime dependencies
  buildInputs = with pkgs; [
    ${dependencies.filter(d => !["python3", "pkg-config"].includes(d)).join("\n    ")}
  ];` : ""}

  ${inspection.hasBrokenSymlinks ? `# Clean up broken symlinks from monorepo structure
  postInstall = ''
    # Remove broken symlinks pointing to missing workspace packages
    find $out -type l ! -exec test -e {} \\; -delete
    
    # Recreate main executable if needed
    # ln -sf $out/lib/node_modules/${packageName}/dist/index.js $out/bin/${packageName}
  '';` : ""}

  ${options.npm_flags && options.npm_flags.length > 0 ? `npmFlags = [ ${options.npm_flags.map((f: string) => `"${f}"`).join(" ")} ];` : ""}

  meta = with pkgs.lib; {
    description = "${packageName} - ${inspection.description || "Package"}";
    platforms = platforms.linux;
    ${inspection.license ? `license = licenses.${this.mapLicense(inspection.license)};` : ""}
  };
}
`;

    return { content, dependencies };
  }

  /**
   * Configure DEB package
   */
  private async configureDebPackage(
    packageName: string,
    storageFile: string,
    sha256: string,
    options: any
  ): Promise<{ content: string }> {
    const content = `# ${packageName} - DEB Package Configuration
# Auto-generated by MCP Package Debugger
{
  ${packageName} = {
    enable = true;

    # Source configuration
    source = {
      path = ../storage/${storageFile.split('/').pop()};
      sha256 = "${sha256}";
    };

    # Sandbox configuration
    sandbox = {
      enable = ${options.sandbox !== false};
      blockHardware = [];
      allowedPaths = [ "$HOME" ];
    };

    # Audit configuration
    audit = {
      enable = ${options.audit !== false};
      logLevel = "info";
    };

    # Desktop entry (set to null if not a GUI application)
    desktopEntry = null;
  };
}
`;

    return { content };
  }

  /**
   * Inspect tarball structure
   */
  private async inspectTarball(
    tarPath: string
  ): Promise<{
    executables: string[];
    hasLibraries: boolean;
    complexity: "simple" | "medium" | "complex";
    hasGui: boolean;
    needsHome: boolean;
  }> {
    // List tarball contents
    const files = await this.listTarballFiles(tarPath);
    
    // Find executables (heuristic: files in bin/ or files without extension)
    const executables: string[] = [];
    let hasLibraries = false;
    let hasGui = false;
    
    for (const file of files) {
      // Check for executables
      if (file.includes("/bin/") || file.match(/\/[^/.]+$/)) {
        const execPath = file.replace(/^[^/]+\//, ""); // Remove top-level directory
        if (!execPath.includes(".")) {
          executables.push(execPath);
        }
      }
      
      // Check for libraries
      if (file.includes(".so")) {
        hasLibraries = true;
      }
      
      // Check for GUI indicators
      if (file.includes(".desktop") || file.includes("/share/applications/")) {
        hasGui = true;
      }
    }

    // Determine complexity
    const libCount = files.filter(f => f.includes(".so")).length;
    const complexity = libCount > 10 ? "complex" : libCount > 3 ? "medium" : "simple";

    // Check if needs home directory
    const needsHome = files.some(f => f.includes("config") || f.includes(".rc"));

    return {
      executables,
      hasLibraries,
      complexity,
      hasGui,
      needsHome,
    };
  }

  /**
   * Inspect NPM package
   */
  private async inspectNpmPackage(
    tarPath: string
  ): Promise<{
    hasNativeModules: boolean;
    needsLibsecret: boolean;
    needsGtk: boolean;
    hasBrokenSymlinks: boolean;
    description?: string;
    license?: string;
  }> {
    // List tarball contents
    const files = await this.listTarballFiles(tarPath);
    
    // Check for native modules
    const hasNativeModules = files.some(
      f => f.includes("binding.gyp") || f.includes("node_modules") && f.includes(".node")
    );

    // Check for specific dependencies
    const needsLibsecret = files.some(f => f.includes("keytar") || f.includes("libsecret"));
    const needsGtk = files.some(f => f.includes("gtk") || f.includes("gdk"));
    
    // Check for workspace symlinks (monorepo indicator)
    const hasBrokenSymlinks = files.some(f => f.includes("node_modules/@"));

    // Try to extract package.json info
    let description: string | undefined;
    let license: string | undefined;

    try {
      const packageJsonFiles = files.filter(f => f.endsWith("package.json"));
      if (packageJsonFiles.length > 0) {
        // Extract and parse the first package.json
        const pkgJson = await this.extractFileFromTarball(tarPath, packageJsonFiles[0]);
        const parsed = JSON.parse(pkgJson);
        description = parsed.description;
        license = parsed.license;
      }
    } catch {
      // Ignore parsing errors
    }

    return {
      hasNativeModules,
      needsLibsecret,
      needsGtk,
      hasBrokenSymlinks,
      description,
      license,
    };
  }

  /**
   * List files in tarball
   */
  private async listTarballFiles(tarPath: string): Promise<string[]> {
    return new Promise((resolve, reject) => {
      const tar = spawn("tar", ["-tzf", tarPath]);
      
      let files = "";
      tar.stdout.on("data", (data) => {
        files += data.toString();
      });

      tar.on("close", (code) => {
        if (code === 0) {
          resolve(files.split("\n").filter(f => f.length > 0));
        } else {
          reject(new Error("Failed to list tarball files"));
        }
      });
    });
  }

  /**
   * Extract specific file from tarball
   */
  private async extractFileFromTarball(tarPath: string, filePath: string): Promise<string> {
    return new Promise((resolve, reject) => {
      const tar = spawn("tar", ["-xzf", tarPath, "-O", filePath]);
      
      let content = "";
      tar.stdout.on("data", (data) => {
        content += data.toString();
      });

      tar.on("close", (code) => {
        if (code === 0) {
          resolve(content);
        } else {
          reject(new Error(`Failed to extract ${filePath} from tarball`));
        }
      });
    });
  }

  /**
   * Select appropriate build method
   */
  private selectBuildMethod(
    requested: BuildMethod,
    hasLibraries: boolean,
    complexity: "simple" | "medium" | "complex"
  ): BuildMethod {
    if (requested !== "auto") {
      return requested;
    }

    // Auto-select based on complexity
    if (complexity === "complex" || hasLibraries) {
      return "fhs";
    }

    return "native";
  }

  /**
   * Map common license strings to nixpkgs license identifiers
   */
  private mapLicense(license: string): string {
    const mapping: Record<string, string> = {
      "MIT": "mit",
      "Apache-2.0": "asl20",
      "GPL-3.0": "gpl3",
      "GPL-2.0": "gpl2",
      "BSD-3-Clause": "bsd3",
      "BSD-2-Clause": "bsd2",
      "ISC": "isc",
      "Unlicense": "unlicense",
    };

    return mapping[license] || "unfree";
  }

  /**
   * Get configuration file path
   */
  private getConfigFilePath(packageType: string, packageName: string): string {
    return `modules/packages/${packageType}-packages/packages/${packageName}.nix`;
  }
}